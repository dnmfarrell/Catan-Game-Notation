{
  "name": "ajv",
  "version": "2.5.0",
  "description": "Another JSON Schema Validator",
  "main": "lib/ajv.js",
  "files": [
    "lib/",
    "LICENSE",
    ".tonic_example.js"
  ],
  "scripts": {
    "jshint": "jshint lib/*.js lib/**/*.js --exclude lib/dotjs/**/*",
    "test-spec": "mocha spec/*.spec.js -R spec",
    "test-fast": "AJV_FAST_TEST=true npm run test-spec",
    "test-debug": "mocha spec/*.spec.js --debug-brk -R spec",
    "test-cov": "istanbul cover -x '**/spec/**' node_modules/mocha/bin/_mocha -- spec/*.spec.js -R spec",
    "bundle": "browserify -r ./lib/ajv.js:ajv -o ajv.bundle.js",
    "build": "node scripts/compile-dots.js",
    "test-browser": "scripts/prepare-tests && karma start --single-run --browsers PhantomJS",
    "test": "npm run jshint && npm run build && npm run test-cov && npm run test-browser",
    "prepublish": "npm run build",
    "watch": "watch 'npm run build' ./lib/dot"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/epoberezkin/ajv.git"
  },
  "keywords": [
    "JSON",
    "schema",
    "validator"
  ],
  "author": {
    "name": "Evgeny Poberezkin"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/epoberezkin/ajv/issues"
  },
  "homepage": "https://github.com/epoberezkin/ajv",
  "tonicExampleFilename": ".tonic_example.js",
  "dependencies": {
    "json-stable-stringify": "^1.0.0"
  },
  "devDependencies": {
    "brfs": "^0.0.8",
    "browserify": "^11.0.1",
    "chai": "^3.0.0",
    "coveralls": "^2.11.4",
    "dot": "^1.0.3",
    "glob": "^5.0.10",
    "istanbul": "^0.3.17",
    "js-beautify": "^1.5.6",
    "jshint": "^2.8.0",
    "json-schema-test": "^0.1.6",
    "karma": "^0.13.3",
    "karma-chrome-launcher": "^0.2.0",
    "karma-mocha": "^0.2.0",
    "karma-phantomjs-launcher": "^0.2.1",
    "karma-sauce-launcher": "^0.2.14",
    "mocha": "^2.2.5",
    "phantomjs": "^1.9.18",
    "pre-commit": "^1.1.1",
    "require-globify": "^1.3.0",
    "watch": "^0.16.0"
  },
  "readme": "# ajv - Another JSON Schema Validator\n\nCurrently the fastest JSON Schema validator for node.js and browser.\n\nIt uses [doT templates](https://github.com/olado/doT) to generate super-fast validating functions.\n\n[![Build Status](https://travis-ci.org/epoberezkin/ajv.svg)](https://travis-ci.org/epoberezkin/ajv)\n[![npm version](https://badge.fury.io/js/ajv.svg)](http://badge.fury.io/js/ajv)\n[![Code Climate](https://codeclimate.com/github/epoberezkin/ajv/badges/gpa.svg)](https://codeclimate.com/github/epoberezkin/ajv)\n[![Test Coverage](https://codeclimate.com/github/epoberezkin/ajv/badges/coverage.svg)](https://codeclimate.com/github/epoberezkin/ajv/coverage)\n\n\nNB: [Upgrading to version 2.0.0](https://github.com/epoberezkin/ajv/releases/tag/2.0.0).\n\n\n## Features\n\n- ajv implements full [JSON Schema draft 4](http://json-schema.org/) standard:\n  - all validation keywords (see [JSON-Schema validation keywords](https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md))\n  - full support of remote refs (remote schemas have to be added with `addSchema` or compiled to be available)\n  - support of circular dependencies between schemas\n  - correct string lengths for strings with unicode pairs (can be turned off)\n  - [formats](#formats) defined by JSON Schema draft 4 standard and custom formats (can be turned off)\n  - [validates schemas against meta-schema](#api-validateschema)\n- supports [browsers](#using-in-browser) and nodejs 0.10-5.0\n- [asynchronous loading](#asynchronous-compilation) of referenced schemas during compilation\n- \"All errors\" validation mode with [option allErrors](#options)\n- [error messages with parameters](#validation-errors) describing error reasons to allow creating custom error messages\n- i18n error messages support with [ajv-i18n](https://github.com/epoberezkin/ajv-i18n) package (version >= 1.0.0)\n- [filtering data](#filtering-data) from additional properties\n- [custom keywords](#defining-custom-keywords)\n- NEW: keywords `switch`, `constant`, `contains`, `patternGroups`, `formatMaximum`/`formatMinimum` and `exclusiveFormatMaximum`/`exclusiveFormatMinimum` from [JSON-schema v5 proposals](https://github.com/json-schema/json-schema/wiki/v5-Proposals) with [option v5](#options)\n- NEW: [v5 meta-schema](https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#) for schemas using v5 keywords.\n\nCurrently ajv is the only validator that passes all the tests from [JSON Schema Test Suite](https://github.com/json-schema/JSON-Schema-Test-Suite) (according to [json-schema-benchmark](https://github.com/ebdrup/json-schema-benchmark), apart from the test that requires that `1.0` is not an integer that is impossible to satisfy in JavaScript).\n\n\n## Performance\n\najv generates code to turn JSON schemas into javascript functions that are efficient for v8 optimization.\n\nCurrently ajv is the fastest validator according to these benchmarks:\n\n- [json-schema-benchmark](https://github.com/ebdrup/json-schema-benchmark) - 70% faster than the second place\n- [jsck benchmark](https://github.com/pandastrike/jsck#benchmarks) - 20-190% faster\n- [z-schema benchmark](https://rawgit.com/zaggino/z-schema/master/benchmark/results.html)\n- [themis benchmark](https://cdn.rawgit.com/playlyfe/themis/master/benchmark/results.html)\n\n\n## Install\n\n```\nnpm install ajv\n```\n\n\n## Usage\n\nTry it in the node REPL: https://tonicdev.com/npm/ajv\n\n\nThe fastest validation call:\n\n```\nvar Ajv = require('ajv');\nvar ajv = Ajv(); // options can be passed, e.g. {allErrors: true}\nvar validate = ajv.compile(schema);\nvar valid = validate(data);\nif (!valid) console.log(validate.errors);\n```\n\nor with less code\n\n```\n// ...\nvar valid = ajv.validate(schema, data);\nif (!valid) console.log(ajv.errors);\n// ...\n```\n\nor\n\n```\n// ...\najv.addSchema(schema, 'mySchema');\nvar valid = ajv.validate('mySchema', data);\nif (!valid) console.log(ajv.errorsText());\n// ...\n```\n\najv compiles schemas to functions and caches them in all cases (using stringified schema as a key - using [json-stable-stringify](https://github.com/substack/json-stable-stringify)), so that the next time the same schema is used (not necessarily the same object instance) it won't be compiled again.\n\nThe best performance is achieved when using compiled functions returned by `compile` or `getSchema` methods (there is no additional function call).\n\n__Please note__: every time validation function or `ajv.validate` are called `errors` property is overwritten. You need to copy `errors` array reference to another variable if you want to use it later (e.g., in the callback). See [Validation errors](#validation-errors)\n\n\n## Using in browser\n\nYou can require ajv directly from the code you browserify - in this case ajv will be a part of your bundle.\n\nIf you need to use ajv in several bundles you can create a separate browserified bundle using `npm run bundle` script (thanks to [siddo420](https://github.com/siddo420)).\n\nThen you need to load ajv in the browser:\n```\n<script src=\"ajv.bundle.js\"></script>\n```\n\nNow you can use it as shown above - `require` will be global and you can `require('ajv')`.\n\nAjv was tested with these browsers:\n\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/epoberezkin.svg)](https://saucelabs.com/u/epoberezkin)\n\n\n## Formats\n\nThe following formats are supported for string validation with \"format\" keyword:\n\n- _date_: full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n- _time_: time with optional time-zone.\n- _date-time_: date-time from the same source (time-zone is mandatory). `date`, `time` and `date-time` validate ranges in `full` mode and only regexp in `fast` mode (see [options](#options)).\n- _uri_: full uri with optional protocol.\n- _email_: email address.\n- _hostname_: host name acording to http://tools.ietf.org/html/rfc1034#section-3.5\n- _ipv4_: IP address v4.\n- _ipv6_: IP address v6.\n- _regex_: tests whether a string is a valid regular expression by passing it to RegExp constructor.\n\nThere are two modes of format validation: `fast` and `full` that affect all formats but `ipv4` and `ipv6`. See [Options](#options) for details.\n\nYou can add additional formats and replace any of the formats above using [addFormat](#api-addformat) method.\n\nYou can find patterns used for format validation and the sources that were used in [formats.js](https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js).\n\n\n## Defining custom keywords\n\nStarting from version 2.0.0 ajv supports custom keyword definitions.\n\nWARNING: The main drawback of extending JSON-schema standard with custom keywords is the loss of portability of your schemas - it may not be possible to support these custom keywords on some other platforms. Also your schemas may be more challenging to read for other people. If portability is important you may prefer using additional validation logic outside of JSON-schema rather than putting it inside your JSON-schema.\n\nThe advantages of using custom keywords are:\n- they allow you keeping a larger portion of your validation logic in the schema\n- they make your schemas more expressive and less verbose\n- they are fun to use\n\nYou can define custom keywords with [addKeyword](#api-addkeyword) method. Keywords are defined on the `ajv` instance level - new instances will not have previously defined keywords.\n\nAjv allows defining keywords with:\n- validation function\n- compilation function\n- macro function\n- inline compilation function that should return code (as string) that will be inlined in the currently compiled schema.\n\n\n### Define keyword with validation function (NOT RECOMMENDED)\n\nValidation function will be called during data validation. It will be passed schema, data and parentSchema (if it has 3 arguments) at validation time and it should return validation result as boolean. It can return an array of validation errors via `.errors` property of itself (otherwise a standard error will be used).\n\nThis way to define keywords is added as a way to quickly test your keyword and is not recommended because of worse performance than compiling schemas.\n\n\nExample. `constant` keyword from version 5 proposals (that is equivalent to `enum` keyword with one item):\n\n```\najv.addKeyword('constant', { validate: function (schema, data) {\n  return typeof schema == 'object && schema !== null'\n          ? deepEqual(schema, data)\n          : schema === data;\n} });\n\nvar schema = { \"constant\": 2 };\nvar validate = ajv.compile(schema);\nconsole.log(validate(2)); // true\nconsole.log(validate(3)); // false\n\nvar schema = { \"constant\": { \"foo\": \"bar\" } };\nvar validate = ajv.compile(schema);\nconsole.log(validate({foo: 'bar'})); // true\nconsole.log(validate({foo: 'baz'})); // false\n```\n\n`constant` keyword is already available in Ajv with option `v5: true`.\n\n\n### Define keyword with \"compilation\" function\n\nCompilation function will be called during schema compilation. It will be passed schema and parent schema and it should return a validation function. This validation function will be passed data during validation; it should return validation result as boolean and it can return an array of validation errors via `.errors` property of itself (otherwise a standard error will be used).\n\nIn some cases it is the best approach to define keywords, but it has the performance cost of an extra function call during validation. If keyword logic can be expressed via some other JSON-schema then `macro` keyword definition is more efficient (see below).\n\nExample. `range` and `exclusiveRange` keywords using compiled schema:\n\n```\najv.addKeyword('range', { type: 'number', compile: function (sch, parentSchema) {\n  var min = sch[0];\n  var max = sch[1];\n\n  return parentSchema.exclusiveRange === true\n          ? function (data) { return data > min && data < max; }\n          : function (data) { return data >= min && data <= max; }\n} });\n\nvar schema = { \"range\": [2, 4], \"exclusiveRange\": true };\nvar validate = ajv.compile(schema);\nconsole.log(validate(2.01)); // true\nconsole.log(validate(3.99)); // true\nconsole.log(validate(2)); // false\nconsole.log(validate(4)); // false\n```\n\n\n### Define keyword with \"macro\" function\n\n\"Macro\" function is called during schema compilation. It is passed schema and parent schema and it should return another schema that will be applied to the data in addition to the original schema (if schemas have different keys they are merged, otherwise `allOf` keyword is used).\n\nIt is the most efficient approach (in cases when the keyword logic can be expressed with another JSON-schema) because it is usually easy to implement and there is no extra function call during validation.\n\nThe disadvantage of macro keywords is that you won't receive any keyword related error message if it fails (and you can't define custom errors for them).\n\n\nExample. `range` and `exclusiveRange` keywords from the previous example defined with macro:\n\n```\najv.addKeyword('range', { macro: function (schema, parentSchema) {\n  return {\n    minimum: schema[0],\n    maximum: schema[1],\n    exclusiveMinimum: !!parentSchema.exclusiveRange,\n    exclusiveMaximum: !!parentSchema.exclusiveRange\n  };\n} });\n```\n\nExample. `contains` keyword from version 5 proposals that requires that the array has at least one item matching schema (see https://github.com/json-schema/json-schema/wiki/contains-(v5-proposal)):\n\n```\najv.addKeyword('contains', { macro: function (schema) {\n  return { \"not\": { \"items\": { \"not\": schema } } };\n} });\n\nvar schema = {\n  \"contains\": {\n    \"type\": \"number\",\n    \"minimum\": 4,\n    \"exclusiveMinimum\": true\n  }\n};\n\nvar validate = ajv.compile(schema);\nconsole.log(validate([1,2,3])); // false\nconsole.log(validate([2,3,4])); // false\nconsole.log(validate([3,4,5])); // true, number 5 matches schema inside \"contains\"\n```\n\n`contains` keyword is already available in Ajv with option `v5: true`.\n\nSee the example of defining recursive macro keyword `deepProperties` in the [test](https://github.com/epoberezkin/ajv/blob/master/spec/custom.spec.js#L151).\n\n\n### Define keyword with \"inline\" compilation function\n\nInline compilation function is called during schema compilation. It is passed three parameters: `it` (the current schema compilation context), `schema` and `parentSchema` and it should return the code (as a string) that will be inlined in the code of compiled schema. This code can be either an expression that evaluates to the validation result (boolean) or a set of statements that assign the validation result to a variable.\n\nWhile it can be more difficult to define keywords with \"inline\" functions, it can have the best performance.\n\nExample `even` keyword:\n\n```\najv.addKeyword('even', { type: 'number', inline: function (it, schema) {\n  var op = schema ? '===' : '!==';\n  return 'data' + (it.dataLevel || '') + ' % 2 ' + op + ' 0';\n} });\n\nvar schema = { \"even\": true };\n\nvar validate = ajv.compile(schema);\nconsole.log(validate(2)); // true\nconsole.log(validate(3)); // false\n```\n\n`'data' + (it.dataLevel || '')` in the example above is the reference to the currently validated data. Also note that `schema` (keyword schema) is the same as `it.schema.even`, so schema is not strictly necessary here - it is passed for convenience.\n\n\nExample `range` keyword defined using [doT template](https://github.com/olado/doT):\n\n```\nvar doT = require('dot');\nvar inlineRangeTemplate = doT.compile(\"\\\n{{ \\\n  var $data = 'data' + (it.dataLevel || '') \\\n    , $min = it.schema.range[0] \\\n    , $max = it.schema.range[1] \\\n    , $gt = it.schema.exclusiveRange ? '>' : '>=' \\\n    , $lt = it.schema.exclusiveRange ? '<' : '<='; \\\n}} \\\nvar valid{{=it.level}} = {{=$data}} {{=$gt}} {{=$min}} && {{=$data}} {{=$lt}} {{=$max}}; \\\n\");\n\najv.addKeyword('range', {\n  type: 'number',\n  inline: inlineRangeTemplate,\n  statements: true\n});\n```\n\n`'valid' + it.level` in the example above is the expected name of the variable that should be set to the validation result.\n\nProperty `statements` in the keyword definition should be set to `true` if the validation code sets the variable instead of evaluating to the validation result.\n\n\n### Defining errors in custom keywords\n\nAll custom keywords but macro keywords can create custom error messages.\n\nValidating and compiled keywords should define errors by assigning them to `.errors` property of the validation function.\n\nInline custom keyword should increase error counter `errors` and add error to `vErrors` array (it can be null). See [example range keyword](https://github.com/epoberezkin/ajv/blob/master/spec/custom_rules/range_with_errors.jst).\n\nWhen inline keyword performs validation Ajv checks whether it created errors by comparing errors count before and after validation. To skip this check add option `errors` (can be `true` or `false`) to keyword definition:\n\n```\najv.addKeyword('range', {\n  type: 'number',\n  inline: inlineRangeTemplate,\n  statements: true,\n  errors: true // keyword should create custom errors when validation fails\n});\n```\n\nEach error object should have properties `keyword`, `message` and `params`, other properties will be added.\n\nInlined keywords can optionally define `dataPath` property in error objects.\n\nIf custom keyword doesn't create errors, the default error will be created in case the keyword fails validation (see [Validation errors](#validation-errors)).\n\n\n## Asynchronous compilation\n\nDuring asynchronous compilation remote references are loaded using supplied function. See `compileAsync` method and `loadSchema` option.\n\nExample:\n\n```\nvar ajv = Ajv({ loadSchema: loadSchema });\n\najv.compileAsync(schema, function (err, validate) {\n\tif (err) return;\n\tvar valid = validate(data);\n});\n\nfunction loadSchema(uri, callback) {\n\trequest.json(uri, function(err, res, body) {\n\t\tif (err || res.statusCode >= 400)\n\t\t\tcallback(err || new Error('Loading error: ' + res.statusCode));\n\t\telse\n\t\t\tcallback(null, body);\n\t});\n}\n```\n\n\n## Filtering data\n\nWith [option `removeAdditional`](#options) (added by [andyscott](https://github.com/andyscott)) you can filter data during the validation.\n\nThis option modifies original object.\n\nTODO: example\n\n\n## API\n\n##### Ajv(Object options) -&gt; Object\n\nCreate ajv instance.\n\nAll the instance methods below are bound to the instance, so they can be used without the instance.\n\n\n##### .compile(Object schema) -&gt; Function&lt;Object data&gt;\n\nGenerate validating function and cache the compiled schema for future use.\n\nValidating function returns boolean and has properties `errors` with the errors from the last validation (`null` if there were no errors) and `schema` with the reference to the original schema.\n\nUnless the option `validateSchema` is false, the schema will be validated against meta-schema and if schema is invalid the error will be thrown. See [options](#options).\n\n\n##### .compileAsync(Object schema, Function callback)\n\nAsyncronous version of `compile` method that loads missing remote schemas using asynchronous function in `options.loadSchema`. Callback will always be called with 2 parameters: error (or null) and validating function. Error will be not null in the following cases:\n\n- missing schema can't be loaded (`loadSchema` calls callback with error).\n- the schema containing missing reference is loaded, but the reference cannot be resolved.\n- schema (or some referenced schema) is invalid.\n\nThe function compiles schema and loads the first missing schema multiple times, until all missing schemas are loaded.\n\nSee example in [Asynchronous compilation](#asynchronous-compilation).\n\n\n##### .validate(Object schema|String key|String ref, data) -&gt; Boolean\n\nValidate data using passed schema (it will be compiled and cached).\n\nInstead of the schema you can use the key that was previously passed to `addSchema`, the schema id if it was present in the schema or any previously resolved reference.\n\nValidation errors will be available in the `errors` property of ajv instance (`null` if there were no errors).\n\n__Please note__: every time this method is called the errors are overwritten so you need to copy them to another variable if you want to use them later.\n\n\n##### .addSchema(Array&lt;Object&gt;|Object schema [, String key])\n\nAdd schema(s) to validator instance. From version 1.0.0 this method does not compile schemas (but it still validates them). Because of that change, dependencies can be added in any order and circular dependencies are supported. It also prevents unnecessary compilation of schemas that are containers for other schemas but not used as a whole.\n\nArray of schemas can be passed (schemas should have ids), the second parameter will be ignored.\n\nKey can be passed that can be used to reference the schema and will be used as the schema id if there is no id inside the schema. If the key is not passed, the schema id will be used as the key.\n\n\nOnce the schema is added, it (and all the references inside it) can be referenced in other schemas and used to validate data.\n\nAlthough `addSchema` does not compile schemas, explicit compilation is not required - the schema will be compiled when it is used first time.\n\nBy default the schema is validated against meta-schema before it is added, and if the schema does not pass validation the exception is thrown. This behaviour is controlled by `validateSchema` option.\n\n\n##### .addMetaSchema(Object schema [, String key])\n\nAdds meta schema that can be used to validate other schemas. That function should be used instead of `addSchema` because there may be instance options that would compile a meta schema incorrectly (at the moment it is `removeAdditional` option).\n\nThere is no need to explicitly add draft 4 meta schema (http://json-schema.org/draft-04/schema and http://json-schema.org/schema) - it is added by default, unless option `meta` is set to `false`. You only need to use it if you have a changed meta-schema that you want to use to validate your schemas. See `validateSchema`.\n\nWith option `v5: true` meta-schema that includes v5 keywords also added. It is available at https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json\n\n\n##### <a name=\"api-validateschema\"></a>.validateSchema(Object schema) -&gt; Boolean\n\nValidates schema. This method should be used to validate schemas rather than `validate` due to the inconsistency of `uri` format in JSON-Schema standart.\n\nBy default this method is called automatically when the schema is added, so you rarely need to use it directly.\n\nIf schema doesn't have `$schema` property it is validated against draft 4 meta-schema (option `meta` should not be false) or against [v5 meta-schema](https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#) if option `v5` is true.\n\nIf schema has `$schema` property then the schema with this id (that should be previously added) is used to validate passed schema.\n\nErrors will be available at `ajv.errors`.\n\n\n##### .getSchema(String key) -&gt; Function&lt;Object data&gt;\n\nRetrieve compiled schema previously added with `addSchema` by the key passed to `addSchema` or by its full reference (id). Returned validating function has `schema` property with the reference to the original schema.\n\n\n##### .removeSchema(Object schema|String key|String ref)\n\nRemove added/cached schema. Even if schema is referenced by other schemas it can be safely removed as dependent schemas have local references.\n\nSchema can be removed using key passed to `addSchema`, it's full reference (id) or using actual schema object that will be stable-stringified to remove schema from cache.\n\n\n##### <a name=\"api-addformat\"></a>.addFormat(String name, String|RegExp|Function|Object format)\n\nAdd custom format to validate strings. It can also be used to replace pre-defined formats for ajv instance.\n\nStrings are converted to RegExp.\n\nFunction should return validation result as `true` or `false`.\n\nIf object is passed it should have properties `validate` and `compare`. `validate` can be a string, RegExp or a function as described above. `compare` is a comparison function that accepts two strings and compares them according to the format meaning. This function is used with keywords `formatMaximum`/`formatMinimum` (from [v5 proposals](https://github.com/json-schema/json-schema/wiki/v5-Proposals) - `v5` option should be used). It should return `1` if the first value is bigger than the second value, `-1` if it is smaller and `0` if it is equal.\n\nCustom formats can be also added via `formats` option.\n\n\n##### <a name=\"api-addkeyword\"></a>.addKeyword(String keyword, Object definition)\n\nAdd custom validation keyword to ajv instance.\n\nKeyword should be a valid JavaScript identifier.\n\nKeyword should be different from all standard JSON schema keywords and different from previously defined keywords. There is no way to redefine keywords or to remove keyword definition from the instance.\n\nKeyword definition is an object with the following properties:\n\n- _type_: optional string or array of strings with data type(s) that the keyword will apply to. If keyword is validating another type the validation function will not be called, so there is no need to check for data type inside validation function if `type` property is used.\n- _validate_: validating function\n- _compile_: compiling function\n- _macro_: macro function\n- _inline_: compiling function that returns code (as string)\n\n_validate_, _compile_, _macro_ and _inline_ are mutually exclusive, only one should be used at a time.\n\nWith _macro_ function _type_ must not be specified, the types that the keyword will be applied for will be determined by the final schema.\n\nSee [Defining custom keywords](#defining-custom-keywords) for more details.\n\n\n##### .errorsText([Array&lt;Object&gt; errors [, Object options]]) -&gt; String\n\nReturns the text with all errors in a String.\n\nOptions can have properties `separator` (string used to separate errors, \", \" by default) and `dataVar` (the variable name that dataPaths are prefixed with, \"data\" by default).\n\n\n## Options\n\nDefaults:\n\n```\n{\n  allErrors:        false,\n  removeAdditional: false,\n  verbose:          false,\n  format:           'fast',\n  formats:          {},\n  schemas:          {},\n  meta:             true,\n  validateSchema:   true,\n  inlineRefs:       true,\n  missingRefs:      true,\n  loadSchema:       function(uri, cb) { /* ... */ cb(err, schema); },\n  uniqueItems:      true,\n  unicode:          true,\n  beautify:         false,\n  cache:            new Cache,\n  errorDataPath:    'object',\n  jsonPointers:     false,\n  messages:         true\n  v5:               true\n}\n```\n\n- _allErrors_: check all rules collecting all errors. Default is to return after the first error.\n- _removeAdditional_: remove additional properties. Default is not to remove. If the option is 'all', then all additional properties are removed, regardless of `additionalProperties` keyword in schema (and no validation is made for them). If the option is `true` (or truthy), only additional properties with `additionalProperties` keyword equal to `false` are removed. If the option is 'failing', then additional properties that fail schema validation will be removed too (where `additionalProperties` keyword is schema).\n- _verbose_: include the reference to the part of the schema (`schema` and `parentSchema`) and validated data in errors (false by default).\n- _format_: formats validation mode ('fast' by default). Pass 'full' for more correct and slow validation or `false` not to validate formats at all. E.g., 25:00:00 and 2015/14/33 will be invalid time and date in 'full' mode but it will be valid in 'fast' mode.\n- _formats_: an object with custom formats. Keys and values will be passed to `addFormat` method.\n- _schemas_: an array or object of schemas that will be added to the instance. If the order is important, pass array. In this case schemas must have IDs in them. Otherwise the object can be passed - `addSchema(value, key)` will be called for each schema in this object.\n- _meta_: add [meta-schema](http://json-schema.org/documentation.html) so it can be used by other schemas (true by default).\n- _validateSchema_: validate added/compiled schemas against meta-schema (true by default). `$schema` property in the schema can either be http://json-schema.org/schema or http://json-schema.org/draft-04/schema or absent (draft-4 meta-schema will be used) or can be a reference to the schema previously added with `addMetaSchema` method. If the validation fails, the exception is thrown. Pass \"log\" in this option to log error instead of throwing exception. Pass `false` to skip schema validation.\n- _inlineRefs_: by default the referenced schemas that don't have refs in them are inlined, regardless of their size - that substantially improves performance at the cost of the bigger size of compiled schema functions. Pass `false` to not inline referenced schemas (they will be compiled as separate functions). Pass integer number to limit the maximum number of keywords of the schema that will be inlined.\n- _missingRefs_: by default if the reference cannot be resolved during compilation the exception is thrown. The thrown error has properties `missingRef` (with hash fragment) and `missingSchema` (without it). Both properties are resolved relative to the current base id (usually schema id, unless it was substituted). Pass 'ignore' to log error during compilation and pass validation. Pass 'fail' to log error and successfully compile schema but fail validation if this rule is checked.\n- _loadSchema_: asynchronous function that will be used to load remote schemas when the method `compileAsync` is used and some reference is missing (option `missingRefs` should not be 'fail' or 'ignore'). This function should accept 2 parameters: remote schema uri and node-style callback. See example in Asynchronous compilation.\n- _uniqueItems_: validate `uniqueItems` keyword (true by default).\n- _unicode_: calculate correct length of strings with unicode pairs (true by default). Pass `false` to use `.length` of strings that is faster, but gives \"incorrect\" lengths of strings with unicode pairs - each unicode pair is counted as two characters.\n- _beautify_: format the generated function with [js-beautify](https://github.com/beautify-web/js-beautify) (the validating function is generated without line-breaks). `npm install js-beautify` to use this option. `true` or js-beautify options can be passed.\n- _cache_: an optional instance of cache to store compiled schemas using stable-stringified schema as a key. For example, set-associative cache [sacjs](https://github.com/epoberezkin/sacjs) can be used. If not passed then a simple hash is used which is good enough for the common use case (a limited number of statically defined schemas). Cache should have methods `put(key, value)`, `get(key)` and `del(key)`.\n- _errorDataPath_: set `dataPath` to point to 'object' (default) or to 'property' (default behavior in versions before 2.0) when validating keywords `required`, `additionalProperties` and `dependencies`.\n- _jsonPointers_: set `dataPath` propery of errors using [JSON Pointers](https://tools.ietf.org/html/rfc6901) instead of JavaScript property access notation.\n- _messages_: Include human-readable messages in errors. `true` by default. `messages: false` can be added when custom messages are used (e.g. with [ajv-i18n](https://github.com/epoberezkin/ajv-i18n)).\n- _v5_: add keywords `switch`, `constant`, `contains`, `patternGroups`, `formatMaximum`/`formatMinimum` and `exclusiveFormatMaximum`/`exclusiveFormatMinimum` from [JSON-schema v5 proposals](https://github.com/json-schema/json-schema/wiki/v5-Proposals). With this option added schemas without `$schema` property are validated against [v5 meta-schema](https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#).\n\n\n## Validation errors\n\nIn case of validation failure Ajv assigns the array of errors to `.errors` property of validation function (or to `.errors` property of ajv instance in case `validate` or `validateSchema` methods were called).\n\n\n### Error objects\n\nEach error is an object with the following properties:\n\n- _keyword_: validation keyword. For user defined validation keywords it is set to `\"custom\"` (with the exception of macro keywords and unless keyword definition defines its own errors).\n- _dataPath_: the path to the part of the data that was validated. By default `dataPath` uses JavaScript property access notation (e.g., `\".prop[1].subProp\"`). When the option `jsonPointers` is true (see [Options](#options)) `dataPath` will be set using JSON pointer standard (e.g., `\"/prop/1/subProp\"`).\n- _schemaPath_: the path (JSON pointer) to the schema of the keyword that failed validation.\n- _params_: the object with the additional information about error that can be used to create custom error messages (e.g., using [ajv-i18n](https://github.com/epoberezkin/ajv-i18n) package). See below for parameters set by all keywords.\n- _message_: the standard error message (can be excluded with option `messages` set to false).\n- _schema_: the schema of the keyword (added with `verbose` option).\n- _parentSchema_: the schema containing the keyword (added with `verbose` option)\n- _data_: the data validated by the keyword (added with `verbose` option).\n\n\n### Error parameters\n\nProperties of `params` object in errors depend on the keyword that failed validation.\n\n- `maxItems`, `minItems`, `maxLength`, `minLength`, `maxProperties`, `minProperties` - property `limit` (number, the schema of the keyword).\n- `additionalItems` - property `limit` (the maximum number of allowed items in case when `items` keyword is an array of schemas and `additionalItems` is false).\n- `additionalProperties` - property `additionalProperty` (the property not used in `properties` and `patternProperties` keywords).\n- `patternGroups` (with v5 option) - properties:\n  - `pattern`\n  - `reason` (\"minimum\"/\"maximum\"),\n  - `limit` (max/min allowed number of properties matching number)\n- `dependencies` - properties:\n  - `property` (dependent property),\n  - `missingProperty` (required missing dependency - only the first one is reported currently)\n  - `deps` (required dependencies, comma separated list as a string),\n  - `depsCount` (the number of required dependedncies).\n- `format` - property `format` (the schema of the keyword).\n- `maximum`, `minimum` - properties:\n  - `limit` (number, the schema of the keyword),\n  - `exclusive` (boolean, the schema of `exclusiveMaximum` or `exclusiveMinimum`),\n  - `comparison` (string, comparison operation to compare the data to the limit, with the data on the left and the limit on the right; can be \"<\", \"<=\", \">\", \">=\")\n- `multipleOf` - property `multipleOf` (the schema of the keyword)\n- `pattern` - property `pattern` (the schema of the keyword)\n- `required` - property `missingProperty` (required property that is missing).\n- `type` - property `type` (required type(s), a string, can be a comma-separated list)\n- `uniqueItems` - properties `i` and `j` (indices of duplicate items).\n- `$ref` - property `ref` with the referenced schema URI.\n- custom keywords (in case keyword definition doesn't create errors) - property `keyword` (the keyword name).\n\n\n## Command line interface\n\nSimple JSON-schema validation can be done from command line using [ajv-cli](https://github.com/jessedc/ajv-cli) package. At the moment it does not support referenced schemas.\n\n\n## Tests\n\n```\nnpm install\ngit submodule update --init\nnpm test\n```\n\n## Contributing\n\nAll validation functions are generated using doT templates in [dot](https://github.com/epoberezkin/ajv/tree/master/lib/dot) folder. Templates are precompiled so doT is not a run-time dependency.\n\n`npm run build` - compiles templates to [dotjs](https://github.com/epoberezkin/ajv/tree/master/lib/dotjs) folder.\n\n`npm run watch` - automatically compiles templates when files in dot folder change\n\n\n## Changes history\n\nSee https://github.com/epoberezkin/ajv/releases\n\n\n## License\n\n[MIT](https://github.com/epoberezkin/ajv/blob/master/LICENSE)\n",
  "readmeFilename": "README.md",
  "_id": "ajv@2.5.0",
  "dist": {
    "shasum": "91e0ca640c3c29a769fe119a9db4098c9f4ee37c"
  },
  "_from": "ajv@",
  "_resolved": "https://registry.npmjs.org/ajv/-/ajv-2.5.0.tgz"
}
